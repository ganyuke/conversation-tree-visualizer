<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LLM Chat Tree — Card Nodes (D3.js)</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #0f152b;
      --text: #e8ebf3;
      --muted: #a6b0cf;
      --user: #2a6dfc10;
      /* translucent blue */
      --assistant: #7c3aed10;
      /* translucent purple */
      --accent: #2a6dfc;
      --accent-2: #7c3aed;
      --link: #374151;
    }

    html,
    body {
      margin: 0;
      height: 100%;
      background: radial-gradient(1200px 800px at 10% 0%, #0a0f23, #060914 60%);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      overflow: hidden;
    }

    header {
      position: fixed;
      top: 12px;
      left: 12px;
      right: 12px;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      background: color-mix(in oklab, var(--panel) 80%, transparent);
      border: 1px solid #1f2a44;
      padding: 10px 12px;
      border-radius: 12px;
      box-shadow: 0 6px 30px rgba(0, 0, 0, .25);
      z-index: 10;
    }

    header .title {
      font-weight: 700;
      letter-spacing: .3px;
    }

    header button {
      appearance: none;
      border: 1px solid #263253;
      background: #121a36;
      color: var(--text);
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
    }

    header button:hover {
      filter: brightness(1.15);
    }

    #chart {
      position: absolute;
      inset: 0;
      top: 64px;
      /* leave space for header */
    }

    /* SVG link styling */
    .link {
      fill: none;
      stroke: var(--link);
      stroke-width: 1.5px;
      opacity: .7;
    }

    /* Card nodes rendered via foreignObject > div */
    .node-card {
      gap: 6px;
      display: flex;
      flex-direction: column;
      /* display: grid; grid-template-rows: auto 1fr; gap: 6px; */
      /* width: 260px; fixed width for layout; height clamps via CSS */
      padding: 12px;
      border-radius: 14px;
      border: 1px solid #253258;
      background: #0e1531;
      box-shadow: 0 8px 30px rgba(0, 0, 0, .35);
      height: inherit;
      box-sizing: border-box;
    }

    .node-card.user {
      background: color-mix(in oklab, var(--user) 100%, #0e1531 80%);
      border-color: #26407a;
    }

    .node-card.assistant {
      background: color-mix(in oklab, var(--assistant) 100%, #0e1531 80%);
      border-color: #4e2b8c;
    }

    .node-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .badge {
      font-size: 11px;
      font-weight: 800;
      letter-spacing: .3px;
      text-transform: uppercase;
      opacity: .9;
    }

    .badge.user {
      color: #8cb2ff;
    }

    .badge.assistant {
      color: #c6a4ff;
    }

    .timestamp {
      color: var(--muted);
      font-size: 11px;
      opacity: .9;
    }

    .node-text {
      color: var(--text);
      line-height: 1.25;
      font-size: 13.5px;
      display: -webkit-box;
      overflow: hidden;
      text-overflow: ellipsis;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      font-size: 13.5px;
      -webkit-box-orient: vertical;
      /* flex-grow: 1; */
      white-space: pre-wrap;
      /* preserve newlines */
    }

    .node-actions {
      display: flex;
      gap: 8px;
      margin-top: 6px;
      flex-grow: 1;
    }

    .node-btn {
      border: 1px solid #2a355e;
      background: #0f1736;
      color: #cdd7ff;
      padding: 4px 6px;
      font-size: 11.5px;
      border-radius: 8px;
      cursor: pointer;
    }

    .node-hover {
      transition: transform .1s ease-out, box-shadow .15s ease-out;
    }

    .node-hover:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 30px rgba(0, 0, 0, .45);
    }

    /* Subtle focus ring when a node is clicked */
    .node-focused {
      outline: 2px solid color-mix(in oklab, var(--accent) 70%, transparent);
      outline-offset: 2px;
      border-radius: 16px;
    }

    #minimap {
  position: fixed;
  right: 12px; bottom: 12px;
  width: 240px; height: 160px;  /* tweak */
  border: 1px solid #263253; border-radius: 8px;
  background: rgba(15, 23, 54, 0.8);
  backdrop-filter: blur(2px);
  z-index: 30;
}
#minimap .viewbox {
  fill: none;
  stroke: #8cb2ff;
  stroke-width: 1.5;
  vector-effect: non-scaling-stroke;
}


    /* Helper tooltip style for long text via title attribute is native; optional custom tooltip omitted for brevity */
  </style>
</head>

<body>
  <!--
    HOW TO USE
    1) Save this file and open it in a browser.
    2) Replace the `data` constant below with your own conversation tree.
       Structure: { speaker: 'user' | 'assistant', text: '...', timestamp?: '...', children?: [ ... ] }
    3) Click any card to expand/collapse that branch. Use the buttons to Fit, Expand All, Collapse All.

    TIP: If you want deeper customization or React, port this to react-d3-tree and replace nodeRenderer.
  -->

  <header>
    <div class="title">LLM Chat Tree — Card Nodes</div>
    <button id="fit">Fit to Screen</button>
    <button id="expand">Expand All</button>
    <button id="collapse">Collapse All</button>
    <input id="convfile" type="file" accept=".json" />
    <script>
      document.getElementById('convfile').addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const text = await file.text();
        const exportJson = JSON.parse(text);

        // Get all trees
        const results = chatgptExportToD3(exportJson, {
          includeSystem: false, // set true if you want system prompts in the tree
          includeTool: false    // set true if you want tool/function messages
        });

        console.log("Converted trees:", results);

        // Example: pick the first conversation
        const first = results[0];
        // `first.tree` is the object your D3 code expects as `data`
        // e.g., window.data = first.tree; update(root) ... (where applicable)
        setRoot(first.tree)
      });
    </script>

  </header>
<div id="minimap"></div>

  <div id="chart"></div>
  <script>
        const zoom = d3.zoom()
      .scaleExtent([0.3, 2.5])
      .on('zoom', (event) => g.attr('transform', event.transform));

      
    // --- Build the minimap SVG ---
const miniW = 240, miniH = 160, miniPad = 8;
const miniSvg = d3.select('#minimap').append('svg')
  .attr('width', miniW).attr('height', miniH);
const miniG = miniSvg.append('g');           // content in minimap
const miniView = miniSvg.append('rect')      // shows current viewport
  .attr('class', 'viewbox');

// Brush to control the main viewport from the minimap
const brush = d3.brush()
  .extent([[0,0],[miniW,miniH]])
  .on('brush end', brushed);
miniSvg.append('g').attr('class','mini-brush').call(brush);

// Internal mapping from tree coords -> minimap coords
let miniK = 1, miniTx = 0, miniTy = 0;

// Convert main (y,x) -> minimap (X,Y)
function toMini(y, x) {
  return [miniTx + miniK * y, miniTy + miniK * x];
}

function rebuildMinimap() {
  const { minX, maxX, minY, maxY, w, h } = layoutExtents();

  const miniW = 240, miniH = 160, miniPad = 8;

  // Fit whole tree bounds into the minimap
  const kx = (miniW - miniPad*2) / w;
  const ky = (miniH - miniPad*2) / h;
  miniK = Math.max(0.0001, Math.min(kx, ky)); // never 0/NaN
  miniTx = miniPad - miniK * minY;
  miniTy = miniPad - miniK * minX;

  // Draw links as straight lines (cheap)
  const links = root.links();
  const miniLinks = miniG.selectAll('line.mini-link').data(links, d => d.target.id);
  miniLinks.enter().append('line')
    .attr('class','mini-link')
    .attr('stroke','#3a466f').attr('stroke-width',1).attr('opacity',0.7)
    .merge(miniLinks)
    .attr('x1', d => miniTx + miniK * d.source.y)
    .attr('y1', d => miniTy + miniK * d.source.x)
    .attr('x2', d => miniTx + miniK * d.target.y)
    .attr('y2', d => miniTy + miniK * d.target.x);
  miniLinks.exit().remove();

  // Draw tiny node markers
  const nodes = root.descendants();
  const miniNodes = miniG.selectAll('rect.mini-node').data(nodes, d => d.id);
  miniNodes.enter().append('rect')
    .attr('class','mini-node')
    .attr('width', 3).attr('height', 3)
    .attr('fill', d => d.data.speaker === 'user' ? '#8cb2ff' : '#c6a4ff')
    .merge(miniNodes)
    .attr('x', d => miniTx + miniK * d.y - 1.5)
    .attr('y', d => miniTy + miniK * d.x - 1.5);
  miniNodes.exit().remove();
}


// Update the blue viewport rect when the main zoom changes
function syncMinimapViewbox() {
  const t = d3.zoomTransform(svg.node());
  const svgW = +svg.attr('width'), svgH = +svg.attr('height');

  const contentX0 = (-t.y) / t.k;           // top-left in tree coords (x vertical)
  const contentY0 = (-t.x) / t.k;           // top-left in tree coords (y horizontal)
  const contentW  = svgW / t.k;
  const contentH  = svgH / t.k;

  const [mx, my] = toMini(contentY0, contentX0);
  miniView
    .attr('x', mx).attr('y', my)
    .attr('width', miniK * contentW)
    .attr('height', miniK * contentH);
}

// When user brushes the minimap, move/zoom the main view
function brushed(ev) {
  if (!ev.selection) return;
  const [[x0,y0],[x1,y1]] = ev.selection;

  // Convert selection back to tree coords
  const selY0 = (x0 - miniTx) / miniK; // horizontal in tree coords
  const selX0 = (y0 - miniTy) / miniK; // vertical in tree coords
  const selY1 = (x1 - miniTx) / miniK;
  const selX1 = (y1 - miniTy) / miniK;

  const svgW = +svg.attr('width'), svgH = +svg.attr('height');
  const k = Math.min(svgW / (selY1 - selY0), svgH / (selX1 - selX0));
  const tx = (svgW / 2) - k * ((selY0 + selY1) / 2);
  const ty = (svgH / 2) - k * ((selX0 + selX1) / 2);

  svg.call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(k));
}

// Hook into your existing zoom to keep the minimap synced
zoom.on('zoom.minimap', (event) => {
  g.attr('transform', event.transform);
  syncMinimapViewbox();
});

// Call this after each `update(root)` or any data change:

  </script>
  <script>
    // ======== SAMPLE DATA (Replace with your own) ========
    const data = {
      speaker: 'user',
      text: 'Plan me a weekend in Tokyo. I like food and tech.',
      timestamp: '2025-08-10 09:12',
      children: [
        {
          speaker: 'assistant',
          text: 'Great! Do you prefer street food crawls or Michelin-tier experiences? I can also weave in Akihabara and TeamLab.',
          timestamp: '2025-08-10 09:12',
          children: [
            {
              speaker: 'user',
              text: 'Street food, lots of walking. Keep it cheap.',
              timestamp: '2025-08-10 09:13',
              children: [
                {
                  speaker: 'assistant',
                  text: 'Copy! Here are three sample routes for day 1 with yakitori alleys, ramen counters, and a retro arcade stop.',
                  timestamp: '2025-08-10 09:13'
                },
                {
                  speaker: 'assistant',
                  text: 'Alt plan: Tsukiji outer market early, Asakusa snack crawl, Ueno park stroll, and Akihabara retro. (Click to expand for details...)',
                  timestamp: '2025-08-10 09:14'
                }
              ]
            },
            {
              speaker: 'user',
              text: 'Michelin please — tasting menus are fine.',
              timestamp: '2025-08-10 09:13',
              children: [
                {
                  speaker: 'assistant',
                  text: 'Understood. I can propose 2× tasting menus and a coffee omakase, with exhibit/bookstore stops between.',
                  timestamp: '2025-08-10 09:14'
                }
              ]
            }
          ]
        },
        {
          speaker: 'assistant',
          text: 'Here is a cost-sensitive itinerary with public transit optimizations and some gadget stops.',
          timestamp: '2025-08-10 09:12'
        }
      ]
    };

    // ======== CONFIG ========
    const NODE_W = 260;   // card width in px (keep in sync with CSS)
    const NODE_H = 120;   // virtual height used for layout spacing
    const NODE_H_GAP = 30; // extra space between siblings
    const H_GAP = 80;    // horizontal gap between columns
    const V_GAP = 36;    // vertical gap within column (link curvature)

    const chartEl = document.getElementById('chart');
    const width = chartEl.clientWidth || window.innerWidth;
    const height = chartEl.clientHeight || (window.innerHeight - 64);

    const svg = d3.select('#chart').append('svg')
      .attr('width', width)
      .attr('height', height)
      .attr('viewBox', [0, 0, width, height])
      .style('display', 'block');

    const g = svg.append('g'); // zoom/pan container

    svg.call(zoom);


    // Collapse helper: collapse all children recursively
    function collapse(d) {
      if (d.children) {
        d._children = d.children;
        d._children.forEach(collapse);
        d.children = null;
      }
    }

    function resizeCards() {
      g.selectAll('foreignObject.node-fo').each(function (d) {
        const fo = d3.select(this);
        const card = fo.select('div').node();
        const h = Math.ceil(card.scrollHeight);   // actual content height
        d._cardH = h;                             // stash for spacing logic
        fo.attr('height', h).attr('y', -h / 2);     // fit and center
      });
    }

    function buildRoot(data) {
        const root = d3.hierarchy(data);
        // Start with first level expanded for a nice initial view
        root.x0 = height / 2;
        root.y0 = 40;
        root.each(d => { d.id = crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2) });
        root.children && root.children.forEach(c => {
          // keep first child expanded, collapse deeper levels by default
          c.children && c.children.forEach(grand => grand && collapse(grand));
        });
        return root;
      }

      const tree = d3.tree().nodeSize([NODE_H + NODE_H_GAP, NODE_W + H_GAP]);


      let root;

      function setRoot(data) {
          root = buildRoot(data);
          // First render
          update(root);
          // Slight delay to allow layout, then fit
          setTimeout(() => {
            fitToScreen(60);
          }, 50);
      }

      setRoot(data);

   function update(source) {
      // Compute new tree layout
      const nodes = root.descendants();
      const links = root.links();
      tree(root);

      // Normalize for fixed-depth columns
      nodes.forEach(d => d.y = d.depth * (NODE_W + H_GAP));

      // ----- LINKS -----
      const link = g.selectAll('path.link')
        .data(links, d => d.target.id);

      link.enter()
        .insert('path', 'g')
        .attr('class', 'link')
        .attr('d', d => {
          const o = { x: source.x0 ?? source.x, y: source.y0 ?? source.y };
          return diagonal(o, o);
        })
        .merge(link)
        .transition().duration(350)
        .attr('d', d => diagonal(d.source, d.target));

      link.exit()
        .transition().duration(300)
        .attr('d', d => {
          const o = { x: source.x, y: source.y };
          return diagonal(o, o);
        })
        .remove();

      // ----- NODES -----
      const node = g.selectAll('g.node')
        .data(nodes, d => d.id);

      const nodeEnter = node.enter().append('g')
        .attr('class', 'node')
        .attr('transform', d => `translate(${source.y0 ?? source.y},${source.x0 ?? source.x})`)
        .on('click', (event, d) => {
          d3.selectAll('.node-fo').classed('node-focused', false);
          const fo = d3.select(event.currentTarget).select('.node-fo');
          fo.classed('node-focused', true);
          // toggle
          if (d.children) { d._children = d.children; d.children = null; }
          else { d.children = d._children; d._children = null; }
          update(d);
          event.stopPropagation();
        });

      // Use foreignObject to render an HTML card inside SVG
      const fo = nodeEnter.append('foreignObject')
        .attr('class', 'node-fo node-hover')
        .attr('x', -NODE_W / 2)
        .attr('y', -NODE_H / 2)
        .attr('width', NODE_W)
        .attr('height', NODE_H);

      const card = fo.append('xhtml:div')
        .attr('class', d => `node-card ${d.data.speaker === 'user' ? 'user' : 'assistant'}`)
        .attr('title', d => d.data.text);

      const meta = card.append('div').attr('class', 'node-meta');
      meta.append('div')
        .attr('class', d => `badge ${d.data.speaker}`)
        .text(d => (d.data.speaker || 'node').toUpperCase());
      meta.append('div')
        .attr('class', 'timestamp')
        .text(d => d.data.timestamp || '');

      card.append('div')
        .attr('class', 'node-text')
        .text(d => d.data.text || '');

      // (Optional) Inline node actions
      const actions = card.append('div').attr('class', 'node-actions');
      actions.append('button').attr('class', 'node-btn').text('Toggle').on('click', (e, d) => {
        e.stopPropagation();
        if (d.children) { d._children = d.children; d.children = null; }
        else { d.children = d._children; d._children = null; }
        update(d);
      });

      // UPDATE + TRANSITION
      const nodeMerge = nodeEnter.merge(node);

      nodeMerge.transition().duration(350)
        .attr('transform', d => `translate(${d.y},${d.x})`);

      // EXIT
      const nodeExit = node.exit().transition().duration(300)
        .attr('transform', d => `translate(${source.y},${source.x})`)
        .remove();

      // Stash old positions for smooth transitions
      nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });

      rebuildMinimap();
      syncMinimapViewbox();
    }



    function diagonal(s, d) {
      // Smooth horizontal edge
      const path = `M ${s.y + NODE_W / 2} ${s.x}
                    C ${s.y + NODE_W / 2 + V_GAP} ${s.x},
                      ${d.y - NODE_W / 2 - V_GAP} ${d.x},
                      ${d.y - NODE_W / 2} ${d.x}`;
      return path;
    }

    // Buttons
    document.getElementById('fit').addEventListener('click', () => fitToScreen());
    document.getElementById('expand').addEventListener('click', () => {
      root.each(d => { if (d._children) { d.children = d._children; d._children = null; } });
      update(root);
      setTimeout(() => fitToScreen(60), 410);
    });

    function layoutExtents() {
      const nodes = root.descendants();
      // account for the visual card footprint
      const minX = d3.min(nodes, d => d.x - NODE_H/2);
      const maxX = d3.max(nodes, d => d.x + NODE_H/2);
      const minY = d3.min(nodes, d => d.y - NODE_W/2);
      const maxY = d3.max(nodes, d => d.y + NODE_W/2);

      let w = (maxY - minY);
      let h = (maxX - minX);

      // Guard against degenerate 0/NaN extents (e.g., only root visible)
      if (!isFinite(w) || w < 1) w = NODE_W;
      if (!isFinite(h) || h < 1) h = NODE_H;

      return { minX, maxX, minY, maxY, w, h };
    }

    function fitToScreen(pad = 40) {
      const { minX, maxX, minY, maxY, w, h } = layoutExtents();

      // 2) Compute scale to fit inside the SVG with padding
      const svgW = +svg.attr('width');
      const svgH = +svg.attr('height');
      let scale = Math.min(
        (svgW - pad * 2) / Math.max(1, w),
        (svgH - pad * 2) / Math.max(1, h)
      );
      scale = Math.max(0.3, Math.min(2.0, scale)); // clamp like before

      // 3) Center the content rect in the SVG
      const contentCx = (minY + maxY) / 2;
      const contentCy = (minX + maxX) / 2;

      const tx = (svgW / 2) - scale * contentCx;
      const ty = (svgH / 2) - scale * contentCy;

      svg.transition().duration(400)
        .call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
    }

    document.getElementById('collapse').addEventListener('click', () => {
      // Collapse ALL nodes under the root, including the first visible level
      const kids = root.children;
      if (kids && kids.length) {
        // 1) Recursively move all descendants from `children` -> `_children`
        kids.forEach(function collapse(d) {
          if (d.children) {
            d._children = d.children;
            d.children = null;
          }
          if (d._children) d._children.forEach(collapse);
        });
        // 2) Hide level 1: move root.children itself to root._children
        root._children = kids;
        root.children = null;
      }

      update(root);
      setTimeout(() => fitToScreen(60), 410);
    });

    // Handle resize
    window.addEventListener('resize', () => {
      const w = chartEl.clientWidth || window.innerWidth;
      const h = chartEl.clientHeight || (window.innerHeight - 64);
      svg.attr('width', w).attr('height', h).attr('viewBox', [0, 0, w, h]);
      fitToScreen(60);
    });
  </script>
  <script>
    /**
 * Convert ChatGPT export JSON -> array of D3 trees
 * Output items: { title, id, created, tree }
 *
 * Supports:
 * - Full export: { conversations: [...] } or [ ... ]
 * - Single conversation object with `mapping`
 */
    function chatgptExportToD3(exportData, opts = {}) {
      const conversations = Array.isArray(exportData?.conversations)
        ? exportData.conversations
        : Array.isArray(exportData)
          ? exportData
          : exportData?.mapping
            ? [exportData]
            : [];

      return conversations
        .filter(c => !opts.conversationId || c.id === opts.conversationId)
        .map(c => {
          const tree = chatgptConversationToD3(c, opts);
          return {
            title: c.title || "Untitled conversation",
            id: c.id || c.conversation_id || "",
            created: toISO(c.create_time),
            tree
          };
        });
    }

    /**
     * Convert a single ChatGPT conversation object -> D3 tree
     * Expected D3 node shape: { speaker: 'user'|'assistant', text, timestamp, children: [...] }
     */
    function chatgptConversationToD3(conv, opts = {}) {
      const { includeSystem = false, includeTool = false } = opts;

      // Newer exports still use a `mapping` object of { id: { parent, children, message } }
      const mapping = conv.mapping || {};
      if (!mapping || !Object.keys(mapping).length) {
        // Fallback: some very old formats had a flat messages array
        if (Array.isArray(conv.messages)) {
          return flatMessagesToTree(conv.messages, { includeSystem, includeTool });
        }
        return { speaker: "assistant", text: "(empty)", children: [] };
      }

      // Find root(s). Typically there is one entry with parent === null
      const rootId = Object.keys(mapping).find(id => mapping[id]?.parent == null)
        || Object.keys(mapping)[0];

      // Build a node recursively from mapping id
      const buildNode = (id) => {
        const entry = mapping[id];
        if (!entry) return null;

        const msg = entry.message;
        const role = (msg?.author?.role) || "assistant";
        const text = extractText(msg);
        const timestamp = toISO(msg?.create_time);

        // Recursively build children
        const kids = (entry.children || [])
          .map(buildNode)
          .filter(Boolean);

        // Role filtering (optional)
        const keep =
          role === "user" ||
          role === "assistant" ||
          (includeSystem && role === "system") ||
          (includeTool && (role === "tool" || role === "function"));

        // Some mapping nodes are structural (no message); hoist children
        if (!msg || (!text && kids.length === 1)) {
          return kids[0] || null;
        }
        if (!msg && kids.length > 1) {
          // Create a container to keep branching (rare)
          return { speaker: "assistant", text: "", timestamp: "", children: kids };
        }

        if (!keep) {
          // If filtered out but has children, hoist them
          if (kids.length === 1) return kids[0];
          if (kids.length > 1) return { speaker: "assistant", text: "", timestamp: "", children: kids };
          return null;
        }

        return {
          speaker: role === "user" ? "user" : "assistant", // collapse tool/system into assistant style if kept
          text,
          timestamp,
          children: kids
        };
      };

      let rootNode = buildNode(rootId);

      // If root collapsed to null (e.g., all filtered), create a stub
      if (!rootNode) {
        rootNode = { speaker: "assistant", text: "(no visible messages)", children: [] };
      }

      return rootNode;
    }

    /** Extracts human-readable text from various ChatGPT export message shapes */
    function extractText(msg) {
      if (!msg || !msg.content) return "";
      const c = msg.content;

      // Most common: { content_type: "text", parts: [ "...", ... ] }
      if (Array.isArray(c.parts)) {
        return c.parts.filter(Boolean).join("\n\n");
      }

      // Some newer shapes: { text: "..." }
      if (typeof c.text === "string") return c.text;

      // Sometimes content is an array of blocks with `text`
      if (Array.isArray(c)) {
        return c.map(part => part?.text || part?.string_value || "").filter(Boolean).join("\n\n");
      }

      // Fallbacks
      if (typeof c === "string") return c;
      if (typeof c?.value === "string") return c.value;

      return "";
    }

    /** Convert epoch seconds -> ISO local string (or empty) */
    function toISO(epochSeconds) {
      if (!epochSeconds) return "";
      try {
        const d = new Date(epochSeconds * 1000);
        if (isNaN(d.getTime())) return "";
        return d.toISOString().replace("T", " ").replace(/\.\d{3}Z$/, "Z");
      } catch { return ""; }
    }

    /** Very old fallback: linear messages array => simple chain */
    function flatMessagesToTree(messages, { includeSystem = false, includeTool = false } = {}) {
      const nodes = [];
      for (const m of messages) {
        const role = m?.author?.role || m?.role || "assistant";
        const keep =
          role === "user" ||
          role === "assistant" ||
          (includeSystem && role === "system") ||
          (includeTool && (role === "tool" || role === "function"));
        if (!keep) continue;
        nodes.push({
          speaker: role === "user" ? "user" : "assistant",
          text: extractText(m),
          timestamp: toISO(m?.create_time),
          children: []
        });
      }
      // Chain them into a simple forward-only tree
      for (let i = 0; i < nodes.length - 1; i++) nodes[i].children = [nodes[i + 1]];
      return nodes[0] || { speaker: "assistant", text: "(empty)", children: [] };
    }

  </script>
</body>

</html>